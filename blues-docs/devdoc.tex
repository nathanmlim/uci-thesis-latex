\hypertarget{developer-guide}{%
\section{Developer Guide}\label{developer-guide}}

\hypertarget{uml-diagram}{%
\subsection{UML Diagram}\label{uml-diagram}}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{blues-docs/images/uml.png}
\caption[BLUES UML Diagram]{BLUES UML Diagram provides an overview of the class objects involved in the BLUES protocol. Each class object is detailed with the attributes and methods belonging to each object.}
\label{fig:blues-uml}
\end{figure}

\hypertarget{openmmtools-objects}{%
\subsection{OpenMMTools Objects}\label{openmmtools-objects}}

Highlighted in red are 3 objects that we use from the
\texttt{openmmtools} library. They are the \textbf{ThermodynamicState},
\textbf{CompoundThermodynamicState}, and \textbf{SamplerState} objects.
For more details of each class, please see the official
\href{https://openmmtools.readthedocs.io/en/0.18.1/states.html\#thermodynamic-and-sampler-states}{openmmtools
documentation}.

Briefly, the \textbf{ThermodynamicState} class represents the portion of the state of an \texttt{openmm.Context} that does not change with integration (i.e. particles, temperature, or pressure).
The \textbf{CompoundThermodynamicState} class is essentially the same as the \textbf{ThermodynamicState} class except in this package, it is used for the handling the \texttt{openmmtools.alchemy.AlchemicalState} object.
Thus, in order to create the \textbf{CompoundThermodynamicState}, one needs to first create the plain \textbf{ThermodynamicState} object first. 
If a \textbf{CompoundThermodynamicState} object is not provided to the \texttt{blues.ncmc.BLUESSampler} class, one is created using the default parameters from the given \textbf{ThermodynamicState}. 
Lastly, the \textbf{SamplerState} class represents the state of an \texttt{openmm.Context} which does change with integration (i.e positions, velocities, and box\_vectors). 
Within the context of this package, the \textbf{SamplerState} is used to sync information between the MD and NCMC simulations.

\hypertarget{integrators-and-moves}{%
\subsection{Integrators and Moves}\label{integrators-and-moves}}

\subsubsection{Integrators} 
Integrators are the lowest level openmm objects this package interacts with, where each integrator is tied to an \texttt{openmm.Context} that it advances. 
Each integrator is generated by using the embedded function \texttt{_get_integrator()} function within each move class.
The integrators will control whether we are carrying out the Non-equilibrium Candidate Monte Carlo (NCMC) or Molecular Dynamics (MD) simulation.

Every move class has 3 hidden methods: \texttt{_get_integrator()} for generating the integrator of each move class, \texttt{_before_integration()} for performing any necessary setup before integration, and \texttt{after_integration} for performing any cleanup or data collection after integration. 
Every move class also contains the \texttt{apply()} method which carries out calls to the 3 hidden methods and stepping with the integrator.

In this package, we provide the move class \texttt{blues.ncmc.ReportLangevinDynamicsMove} to execute the MD simulation.
As the name suggests, this will carry forward the MD simulation using Langevin dynamics, by generating an \texttt{openmm.LangevinIntegrator}.
This class is essentially the same as the \texttt{openmmtools.LangevinDynamicsMove} but with modifications to the \texttt{apply()} method which allows storing simulation data for the MD simulation.

For running the NCMC simulation, we provide a custom integrator \texttt{blues.integrator.AlchemicalExternalLangevinIntegrator}. 
This integrator is generated in every move which inherits from the base class \texttt{blues.ncmc.NCMCMove}.
Every class which inherits from the base move class must override the \texttt{_propose_positions()} method.
If necessary, one can override the \texttt{_before_integration()} and \texttt{_after_integration()} methods for any necessary setup and cleanup.
Again, these hidden methods will be called when a call is made to the \texttt{apply()} method from the move class.

\subsubsection{Moves}
In order to implement custom NCMC moves, inherit from the base class and override the \texttt{_propose_positions()} method. 
This method is expected to take in a positions array of the atoms to be modified and returns the proposed positions.
In pseudo-code, it would look something like:

\begin{minted}[breaklines]{python}
from blues.ncmc import NCMCMove
class CustomNCMCMove(NCMCMove):
   def _propose_positions(positions):
       """Add 1 nanometer displacement vector."""
       positions_unit = positions.unit
       unitless_displacement = 1.0 / positions_unit
       displacement_vector = unit.Quantity(np.random.randn(3) * unitless_displacement_sigma, positions_unit)
       proposed_positions = positions + displacement_vector
       return proposed_positions
\end{minted}

In this package, we provide the \texttt{blues.ncmc.RandomLigandRotationMove} in order to propose a random ligand rotation about the center of mass.
This class overrides the \texttt{_before_integration()} method for obtaining the masses of the ligand and overrides the \texttt{_propose_positions()} function for generating the rotated coordinates. Updating the context with the rotated coordinates is handled when the \texttt{apply()} method is called in the move class. 
Code snippet of the class is shown below:

\begin{minted}[breaklines]{python}
from blues.ncmc import RandomLigandRotationMove
class RandomLigandRotationMove(NCMCMove):
  def _before_integration(self, context, thermodynamic_state):
     """Obtain the masses of the ligand before integration."""
     super(RandomLigandRotationMove, self)._before_integration(context, thermodynamic_state)
     masses, totalmass = utils.getMasses(self.atom_subset, thermodynamic_state.topology)
     self.masses = masses
  def _propose_positions(self, positions):
      # Calculate the center of mass
      center_of_mass = utils.getCenterOfMass(positions, self.masses)
      reduced_pos = positions - center_of_mass
      # Define random rotational move on the ligand
      rand_quat = mdtraj.utils.uniform_quaternion(size=None)
      rand_rotation_matrix = mdtraj.utils.rotation_matrix_from_quaternion(rand_quat)
      # multiply lig coordinates by rot matrix and add back COM translation from origin
      proposed_positions = numpy.dot(reduced_pos, rand_rotation_matrix) * positions.unit + center_of_mass

      return proposed_positions
\end{minted}

Since BLUES (v0.2.5) the API has been re-written to be more compatible with the \texttt{openmmtools} API.
This means one can turn a regular \href{https://openmmtools.readthedocs.io/en/0.18.1/mcmc.html\#mcmc-move-types}{Markov Chain Monte Carlo (MCMC)} move from the \texttt{openmmtools} library into an NCMC move to be used in this package. In this case, one simply needs to make use of dual inheritance, using the \texttt{blues.ncmc.NCMCMove} that we provide and override the \texttt{_get_integrator()} method to generate the NCMC integrator we
provide, i.e. \texttt{blues.integrator.AlchemicalExternalLangevinIntegrator}.
When using dual inheritance, it is important that you first inherit the desired MCMC move and then the \texttt{blues.ncmc.NCMCMove} class.
For example, if we wanted to take the\texttt{openmmtools.mcmc.MCDisplacementMove} class and turn it into an NCMC move, it would look like:

\begin{minted}[breaklines]{python}
from blues.ncmc import NCMCMove
from openmmtools.mcmc import MCDisplacementMove
class NCMCDisplacementMove(MCDisplacementMove, NCMCMove):
   def _get_integrator(self, thermodynamic_state):
       return NCMCMove._get_integrator(self,thermodynamic_state)

\end{minted}

\hypertarget{bluessampler}{%
\subsection{BLUESSampler}\label{bluessampler}}

The \texttt{blues.ncmc.BLUESSampler} object ties together all the previously mentioned state objects and the two move classes for running the NCMC+MD simulation.
Details of the parameters for this class are listed in the \texttt{module_doc} documentation.
For a more detailed example of it's usage see the \texttt{usage} documentation.
To be explicit, the input parameters refer to the objects below:

\begin{itemize}
\tightlist
\item
  \textbf{thermodynamic\_state} :
  \texttt{openmmtools.states.ThermodynamicState}
\item
  \textbf{alch\_thermodynamic\_state} :
  \texttt{openmmtools.states.CompoundThermodynamicState}
\item
  \textbf{sampler\_state} : \texttt{openmmtools.states.SamplerState}
\item
  \textbf{dynamics\_move} :
  \texttt{blues.ncmc.ReportLangevinDynamicsMove}
\item
  \textbf{ncmc\_move} : \texttt{blues.ncmc.RandomLigandRotationMove}
\item
  \textbf{topology} : \texttt{openmm.Topology}
\end{itemize}

When the \texttt{run()} method in the \texttt{blues.ncmc.BLUESSampler} is called the following takes place:
\begin{itemize}
\item
  \begin{description}
  \item[Initialization:] 
  \begin{itemize}
  \tightlist
  \item
    \texttt{_print_host_info()} : Information print out of host
  \item
    \texttt{_printSimulationTiming()} : Calculation of total number of steps
  \item
    \texttt{equil()} : Equilibration
  \end{itemize}
  \end{description}
\item
  \begin{description}
  \item[BLUES iterations:]
  \begin{itemize}
  \tightlist
  \item
    \texttt{ncmc_move.apply()} : NCMC simulation
  \item
    \texttt{_acceptRejectMove()} : Metropolization
  \item
    \texttt{dynamics_move.apply()} : MD Simulation
  \end{itemize}
  \end{description}
\end{itemize}

A code snippet of the \texttt{run()} method is shown below:

\begin{minted}[breaklines]{python}
def run(self, n_iterations=1):
   context, integrator = cache.global_context_cache.get_context(self.thermodynamic_state)
   utils.print_host_info(context)
   self._printSimulationTiming(n_iterations)
   if self.iteration == 0:
       self.equil(1)

   self.iteration = 0
   for iteration in range(n_iterations):
       self.ncmc_move.apply(self.alch_thermodynamic_state, self.sampler_state)

       self._acceptRejectMove()

       self.dynamics_move.apply(self.thermodynamic_state, self.sampler_state)

       self.iteration += 1
\end{minted}

\hypertarget{initialization}{%
\subsubsection{Initialization}\label{initialization}}

The first thing that occurs when \texttt{run()} is called is the initialization stage.
During this stage, a call is made to \texttt{utils.print_host_info()} and the \texttt{_printSimulationTiming()} method which will print out some information about the host machine , the total number of force evaluations, and simulation time. 
The output will look something like below:

\begin{verbatim}
OpenMM(7.3.1.dev-4a269c0) Context generated for CUDA platform
system = Linux
node = titanpascal
release = 4.15.0-50-generic
version = #54~16.04.1-Ubuntu SMP Wed May 8 15:55:19 UTC 2019
machine = x86_64
processor = x86_64
DeviceIndex = 0
DeviceName = TITAN Xp
UseBlockingSync = true
Precision = single
UseCpuPme = false
CudaCompiler = /usr/local/cuda-9.2/bin/nvcc
TempDirectory = /tmp
CudaHostCompiler =
DisablePmeStream = false
DeterministicForces = false

Total BLUES Simulation Time = 4.0 ps (0.04 ps/Iter)
Total Force Evaluations = 4000
Total NCMC time = 2.0 ps (0.02 ps/iter)
Total MD time = 2.0 ps (0.02 ps/iter)
\end{verbatim}

In the \texttt{blues.ncmc.BLUESSampler} class, there is an \texttt{equil()} method which lets you run iterations of just the MD simulation in order to equilibrate your system before running the NCMC+MD hybrid simulation. 
An equilibration iteration, in this case is controlled by the given attribute \emph{n\_steps} from the \emph{dynamics\_move} class.
For example, if I create a \texttt{blues.ncmc.ReportLangevinDynamicsMove} class with \emph{n\_steps=20} and call the \texttt{blues.ncmc.BLUESSampler.equil(n_iterations=100)}, this will run \emph{(n\_steps x n\_iterations)} or 2000 steps of MD or 2 picoseconds of MD simulation time.
When the \texttt{run()} method is called without a prior call to the \texttt{equil()} method, the class will always run 1 iteration of equilibration in order to set the initial conditions in the MD simulation.
This is required prior to running the NCMC simulation.

\hypertarget{blues-iterations}{%
\subsubsection{BLUES Iterations}\label{blues-iterations}}

\subsubsection{NCMC Simulation}

After at least 1 iteration of equilibration, the \texttt{blues.ncmc.BLUESSampler} class will then proceed forward with running iterations of the NCMC+MD hybrid simulation.
It will first run the NCMC simulation by calling the \texttt{apply()} method on the \textbf{ncmc\_move} class or, for sake of this example, the \texttt{blues.ncmc.RandomLigandRotationMove} class.
The \texttt{apply()} method for the \textbf{ncmc\_move} will take in the \textbf{alch\_thermodynamic\_state} parameter or specifically the \texttt{openmmtools.states.CompoundThermodynamicState} object.

A code snippet of the \texttt{ncmc_move.apply()} method is shown below:

\begin{minted}[breaklines]{python}
def apply(self, thermodynamic_state, sampler_state):
   if self.context_cache is None:
       context_cache = cache.global_context_cache
   else:
       context_cache = self.context_cache
   integrator = self._get_integrator(thermodynamic_state)
   context, integrator = context_cache.get_context(thermodynamic_state, integrator)
   sampler_state.apply_to_context(context, ignore_velocities=False)
   self._before_integration(context, thermodynamic_state)
   try:
       endStep = self.currentStep + self.n_steps
       while self.currentStep < endStep:
           alch_lambda = integrator.getGlobalVariableByName('lambda')
           if alch_lambda == 0.5:
               sampler_state.update_from_context(context)
               proposed_positions = self._propose_positions(sampler_state.positions[self.atom_subset])
               sampler_state.positions[self.atom_subset] = proposed_positions
               sampler_state.apply_to_context(context, ignore_velocities=True)

           nextSteps = endStep - self.currentStep
           stepsToGo = nextSteps
           while stepsToGo > 10:
               integrator.step(10)
               stepsToGo -= 10
           integrator.step(stepsToGo)
           self.currentStep += nextSteps
   except Exception as e:
       print(e)
   else:
       context_state = context.getState(
           getPositions=True,
           getVelocities=True,
           getEnergy=True,
           enforcePeriodicBox=thermodynamic_state.is_periodic)

       self._after_integration(context, thermodynamic_state)
       sampler_state.update_from_context(
           context_state, ignore_positions=False, ignore_velocities=False, ignore_collective_variables=True)
\end{minted}

When the \texttt{apply()} method on \textbf{ncmc\_move} is called, it will first generate the \texttt{blues.integrators.AlchemicalExternalLangevinIntegrator} by calling the \texttt{_get_integrator()} method inherent to the move class. 
Then, it will create (or fetch from the \textbf{context\_cache}) a corresponding \texttt{openmm.Context} given the \textbf{alch\_thermodynamic\_state}.
Next, the \textbf{sampler\_state} which contains the last state of the MD simulation is synced to the
newly created context from the corresponding \textbf{alch\_thermodynamic\_state}.
Particularly, the context will be updated with the \emph{box\_vectors}, \emph{positions}, and
\emph{velocities} from the last state of the MD simulation.

Just prior to integration, a call is made to the \texttt{_before_integration()} method in order to store the initial \emph{energies}, \emph{positions}, \emph{box\_vectors} and the \emph{masses} of the ligand to be rotated.
Then, we actually step with the integrator where we perform the ligand rotation when \emph{lambda} has reached the half-way point or \emph{lambda=0.5}, continuing integration until we have completed the \emph{n\_steps}.
After the integration steps have been completed, a call is made to the \texttt{after_integration} method to store the final \emph{energies}, \emph{positions}, and \emph{box\_vectors}.
Lastly, the \textbf{sampler\_state} is updated from the final state of the context.


\subsubsection{Metropolization}

After advancing the NCMC simulation, a call is made to the \texttt{_acceptRejectMove()} method embedded in the \texttt{blues.ncmc.BLUESSampler} class for metropolization of the proposed move.
A code snippet of the \texttt{_acceptRejectMove()} is shown below:

\begin{minted}[breaklines]{python}
def _acceptRejectMove(self):
   integrator = self.dynamics_move._get_integrator(self.thermodynamic_state)
   context, integrator = cache.global_context_cache.get_context(self.thermodynamic_state, integrator)
   self.sampler_state.apply_to_context(context, ignore_velocities=True)
   alch_energy = self.thermodynamic_state.reduced_potential(context)

   correction_factor = (self.ncmc_move.initial_energy - self.dynamics_move.final_energy + alch_energy - self.ncmc_move.final_energy)
   logp_accept = self.ncmc_move.logp_accept
   randnum = numpy.log(numpy.random.random())

   logp_accept = logp_accept + correction_factor
   if (not numpy.isnan(logp_accept) and logp_accept > randnum):
       self.n_accepted += 1
   else:
       self.accept = False
       self.sampler_state.positions = self.ncmc_move.initial_positions
       self.sampler_state.box_vectors = self.ncmc_move.initial_box_vectors
\end{minted}

Here, is we compute a correction term for switching between the MD and NCMC integrators and factor this in with natural log of the acceptance probability (\textbf{logp\_accept}).
Then, a random number is generated in which: the move is accepted if the random number is less than the \textbf{logp\_accept} or rejected if greater.
When the move is rejected, we set the \emph{positions} and \emph{box\_vectors} on the \textbf{sampler\_state} to the initial positions and box\_vectors from the NCMC simulation.
If the move is accepted, nothing on the \textbf{sampler\_state} is changed so that the following MD simulation will contain the final state of the NCMC simulation.

\subsubsection{MD Simulation}
After metropolization of the previously proposed move, a call is made to the \texttt{apply()} method on the given \textbf{dynamics\_move} object.
In this example, this would refer to the \texttt{blues.ncmc.ReportLangevinDynamicsMove} class to run the MD simulation.
A code snippet of the \mintinline{python}{dynamics_move.apply()} method is shown below:

\begin{minted}[breaklines, autogobble]{python}
def apply(self, thermodynamic_state, sampler_state):
   if self.context_cache is None:
       context_cache = cache.global_context_cache
   else:
       context_cache = self.context_cache

   integrator = self._get_integrator(thermodynamic_state)
   context, integrator = context_cache.get_context(thermodynamic_state, integrator)
   thermodynamic_state.apply_to_context(context)

   sampler_state.apply_to_context(context, ignore_velocities=self.reassign_velocities)
   if self.reassign_velocities:
       context.setVelocitiesToTemperature(thermodynamic_state.temperature)

   self._before_integration(context, thermodynamic_state)
   try:
       endStep = self.currentStep + self.n_steps
       while self.currentStep < endStep:
           nextSteps = endStep - self.currentStep
           stepsToGo = nextSteps
           while stepsToGo > 10:
               integrator.step(10)
               stepsToGo -= 10
           integrator.step(stepsToGo)
           self.currentStep += nextSteps

   except Exception as e:
       print(e)

   else:
       context_state = context.getState(
           getPositions=True,
           getVelocities=True,
           getEnergy=True,
           enforcePeriodicBox=thermodynamic_state.is_periodic)
       self._after_integration(context, thermodynamic_state)
       sampler_state.update_from_context(
           context_state, ignore_positions=False, ignore_velocities=False, ignore_collective_variables=True)

\end{minted}

When the \texttt{apply()} method is called, a very similar procedure to the NCMC simulation occurs. 
The first thing that happens is to generate the integrator through a call to \texttt{_get_integrator()}, where in this given class, it will generate an \texttt{openmm.LangevinIntegrator} given the \textbf{thermodynamic\_state} parameter.
Then, it will create (or fetch from the \textbf{context\_cache}) a corresponding \texttt{openmm.Context} given the \textbf{thermodynamic\_state}.
Next, the \textbf{sampler\_state}, which contains the last state of the NCMC simulation if the previous move was accepted or the initial state of the NCMC simulation if the move was rejected, is used to update \emph{box\_vectors} and \emph{positions} in the newly created \texttt{openmm.Context}. 
In this case, we reassign the \emph{velocities} in the MD simulation in order to preserve detailed balance.

Following, a call is made to \texttt{_before_integration()} to store the intial \emph{positions}, \emph{box\_vectors} and \emph{energies} and then we carry forward with the integration for \emph{n\_steps}.
After the integration steps have been completed, a call is made to the \texttt{after_integration} method to store the final \emph{energies} and \emph{positions}.
Lastly, the \textbf{sampler\_state} object is updated from the final state of the MD simulation context.

This completes 1 iteration of the BLUES cycle. 
Here, the\textbf{sampler\_state} is then used to sync the final state of the MD simulation (i.e. \emph{box\_vectors}, \emph{positions}, and \emph{velocities}) from the previous iteration to the NCMC simulation of the next iteration. 
Then, we repeat the cycle of \textbf{NCMC-\textgreater{} Metropolization -\textgreater{} MD} for the given number of iterations.